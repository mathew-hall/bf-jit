     1                                  %macro jumpifzero 1
     2                                  	mov ebx, [prog]
     3                                  	mov edx, [dp]
     4                                  	
     5                                  	mov eax, [ebx + edx]
     6                                  	test eax, eax
     7                                  	je %1
     8                                  %endmacro
     9                                  
    10                                  %macro jumpifnzero 1
    11                                  	mov ebx, [prog]
    12                                  	mov edx, [dp]
    13                                  	
    14                                  	mov eax, [ebx + edx]
    15                                  	test eax, eax
    16                                  	jne %1
    17                                  %endmacro
    18                                  
    19                                  
    20                                  	extern _printf
    21                                  	
    22                                  	
    23                                  	SECTION .data
    24 00000000 686920776F726C6400      somestring:	db "hi world",0
    25 00000009 256300                  charout:	db "%c",0
    26                                  
    27                                  	SECTION .text
    28                                  	global _main
    29                                  	
    30                                  deceval:
    31 00000000 8B1D[04000000]          	mov ebx, [prog]
    32 00000006 8B15[00000000]          	mov edx, [dp]
    33 0000000C FE0C1A                  	dec byte [edx + ebx]
    34                                  	
    35 0000000F C3                      	ret
    36                                  	
    37                                  inceval:
    38 00000010 8B1D[04000000]          	mov ebx, [prog]
    39 00000016 8B15[00000000]          	mov edx, [dp]
    40 0000001C FE041A                  	inc byte [edx + ebx]
    41                                  	
    42 0000001F C3                      	ret
    43                                  	
    44                                  incdp:
    45 00000020 A1[00000000]            	mov eax, [dp]
    46 00000025 40                      	inc eax
    47 00000026 BB[00000000]            	mov ebx, dp
    48 0000002B 8903                    	mov [ebx], eax
    49                                  	
    50 0000002D C3                      	ret
    51                                  	
    52                                  decdp:
    53 0000002E A1[00000000]            	mov eax, [dp]
    54 00000033 48                      	dec eax
    55 00000034 BB[00000000]            	mov ebx, dp
    56 00000039 8903                    	mov [ebx], eax
    57 0000003B C3                      	ret
    58                                  	
    59                                  	
    60                                  printout:
    61                                  	;stack is at 0x********4
    62                                  
    63 0000003C 8B1D[04000000]          	mov ebx, [prog]
    64 00000042 8B15[00000000]          	mov edx, [dp]
    65                                  	
    66 00000048 81EC0C000000            	sub esp, 0xC; stupid alignment bullshit
    67 0000004E 8A0413                  	mov al, byte [ebx + edx]
    68 00000051 50                      	push eax 
    69 00000052 68[09000000]            	push charout 
    70 00000057 B80FF00FF0              	mov eax, dword 0xF00FF00F
    71 0000005C FFD0                    	call eax
    72                                  	
    73 0000005E 81C414000000            	add esp, 0x14
    74                                  
    75 00000064 C3                      	ret
    76                                  
    77                                  
    78                                  _main:	;stack =   0x*******C
    79 00000065 55                      	push ebp ; 0x*******8
    80 00000066 89E5                    	mov ebp, esp
    81                                  
    82 00000068 81EC30000000            	sub esp, 0x30
    83                                  	
    84 0000006E B8[04000000]            	mov eax, prog
    85 00000073 8920                    	mov [eax], esp
    86 00000075 C6042449                	mov byte [esp], 0x49
    87                                  
    88 00000079 BA[00000000]            	mov edx, dp
    89 0000007E C70200000000            	mov dword [edx], 0
    90                                  	
    91                                  loops:
    92 00000084 E8B3FFFFFF              	call printout
    93 00000089 E872FFFFFF              	call deceval
    94                                  	jumpifnzero loops
    95 0000008E 8B1D[04000000]      <1>  mov ebx, [prog]
    96 00000094 8B15[00000000]      <1>  mov edx, [dp]
    97                              <1> 
    98 0000009A 8B0413              <1>  mov eax, [ebx + edx]
    99 0000009D 85C0                <1>  test eax, eax
   100 0000009F 75E3                <1>  jne %1
   101                                  	; compiler needs to insert jump targets for loops.
   102                                  	; to do this in asm we need to count the [s, dec ]s. Store from/to pairs of pointers
   103                                  	; then use computed indirect branch (jmp [eax])
   104                                  	
   105 000000A1 81C430000000            	add esp,0x30
   106                                  	
   107 000000A7 5D                      	pop ebp
   108 000000A8 C3                      	ret
   109                                  
   110                                  	
   111                                  	SECTION .bss
   112                                  	
   113 00000000 <res 00000004>          dp resw 2
   114 00000004 <res 00000004>          prog resw 2
   115                                  
